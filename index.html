<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Secure PFX/PKCS#12 Certificate Bundle Generator with automatic chain validation and AIA fetching">
    <meta name="keywords" content="pfx, pkcs12, certificate, private key, certificate chain, AIA, Azure WAF">
    <meta name="author" content="Aleksandr Sukhov">
    <meta name="robots" content="noindex, nofollow">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; connect-src 'self' http: https:; object-src 'none'; base-uri 'self'; form-action 'none';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="no-referrer">
    <meta name="theme-color" content="#4CAF50">
    <title>PFX Certificate Bundle Generator - Secure Azure WAF Tool</title>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 90%;
            margin: 0 auto;
            padding: 10px;
            font-size: 0.75em;
            background-color: #fafafa;
        }
        .container {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
        }
        .form-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 180px;
            font-weight: bold;
        }
        input[type="text"], input[type="password"], input[type="file"], textarea {
            padding: 4px;
            width: 400px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
        }
        input[type="file"] {
            padding: 2px;
        }
        textarea {
            width: 100%;
            min-height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }
        button {
            padding: 4px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #45a049;
        }
        .copy-button {
            background-color: #2196F3;
        }
        .copy-button:hover {
            background-color: #0b7dda;
        }
        .clear-button {
            background-color: #f44336;
        }
        .clear-button:hover {
            background-color: #da190b;
        }
        .warning-button {
            background-color: #ff9800;
        }
        .warning-button:hover {
            background-color: #e68900;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }
        .section h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.2em;
        }
        .result-area {
            margin-top: 10px;
        }
        .result-label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .example {
            background-color: #f9f9f9;
            padding: 8px;
            border-left: 3px solid #4CAF50;
            margin-top: 10px;
            font-size: 0.85em;
        }
        .example-title {
            font-weight: bold;
            color: #333;
        }
        .button-group {
            margin-top: 10px;
        }
        .error {
            color: #f44336;
            font-weight: bold;
            margin-top: 5px;
        }
        .success {
            color: #4CAF50;
            font-weight: bold;
            margin-top: 5px;
        }
        .warning {
            color: #ff9800;
            font-weight: bold;
            margin-top: 5px;
        }
        .info {
            color: #2196F3;
            font-weight: bold;
            margin-top: 5px;
        }
        
        h1, h2, h3 {
            font-size: 1.5em;
        }
        
        h3 {
            font-size: 1.2em;
            margin: 5px 0;
        }
        
        .security-badge {
            background-color: #e8f5e9;
            color: #2e7d32;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-bottom: 10px;
            border-left: 3px solid #4CAF50;
        }
        
        .security-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .security-buttons {
            display: flex;
            gap: 5px;
        }
        
        .security-buttons button {
            padding: 3px 8px;
            font-size: 0.8em;
            margin: 0;
        }
        
        .loading {
            position: relative;
            pointer-events: none;
            opacity: 0.7;
        }
        
        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin: -8px 0 0 -8px;
            border: 2px solid #4CAF50;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        button:focus, input:focus, textarea:focus {
            outline: 2px solid #4CAF50;
            outline-offset: 2px;
        }
        
        .cert-info {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #2196F3;
            margin: 10px 0;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }
        
        .cert-info-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 5px;
        }
        
        .chain-status {
            background-color: #fff3e0;
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #ff9800;
            margin: 10px 0;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }
        
        .chain-complete {
            background-color: #e8f5e9;
            border-left: 3px solid #4CAF50;
        }
        
        .chain-incomplete {
            background-color: #ffebee;
            border-left: 3px solid #f44336;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75em;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            input[type="text"], input[type="password"], input[type="file"] {
                width: 100%;
                max-width: 400px;
            }
            
            label {
                width: 100%;
                margin-bottom: 3px;
            }
            
            .security-line {
                flex-direction: column !important;
                align-items: flex-start !important;
            }
            
            .security-buttons {
                margin-top: 5px;
            }
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 4px 10px;
            background-color: #2196F3;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .file-input-label:hover {
            background-color: #0b7dda;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-name-display {
            display: inline-block;
            margin-left: 10px;
            color: #666;
            font-style: italic;
        }
        
        .collapsible-section {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible-section::before {
            content: '▶ ';
            display: inline-block;
            transition: transform 0.3s ease;
        }
        
        .collapsible-section.expanded::before {
            transform: rotate(90deg);
        }
        
        .collapsible-content {
            display: none;
            margin-top: 10px;
        }
        
        .collapsible-content.show {
            display: block;
        }
        
        .two-column-layout {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .column {
            flex: 1;
            min-width: 0;
        }
        
        .column-header {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            font-size: 1.1em;
            text-align: center;
            margin-bottom: 0;
        }
        
        .column-header.checker {
            background-color: #2196F3;
        }
        
        .column-content {
            border: 2px solid #4CAF50;
            border-top: none;
            border-radius: 0 0 5px 5px;
            padding: 10px;
            background-color: #fff;
        }
        
        .column-content.checker {
            border-color: #2196F3;
        }
        
        @media (max-width: 1200px) {
            .two-column-layout {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PFX Certificate Bundle Generator</h1>
        
        <p style="font-style: italic; font-size: 0.8em; text-align: right;">
            Created by Aleksandr Sukhov • Last Updated: December 10, 2025
        </p>
        
        <div class="security-line">
            <div class="security-badge">
                Client-side processing • Memory-only storage • Automatic chain validation • AIA fetching • Azure WAF Ready
            </div>
            <div class="security-buttons">
                <button id="clearAllBtn" class="clear-button">Clear All</button>
                <button id="securityToggleBtn" class="copy-button">Security Status</button>
            </div>
        </div>
        
        <div id="securityReport" class="example" style="display: none; margin-bottom: 10px;">
            <div class="example-title">Security Status</div>
            <div id="securityDetails"></div>
        </div>
        
        <div class="two-column-layout">
            <!-- Left Column: Create PFX Bundle -->
            <div class="column">
                <div class="column-header">Create PFX Bundle</div>
                <div class="column-content">
                
        <!-- Certificate Input Section -->
        <div class="section">
            <h3>Step 1: Provide Certificate(s)</h3>
            
            <div class="form-group">
                <label>Certificate File:</label>
                <div class="file-input-wrapper">
                    <label for="certFile" class="file-input-label">Choose File</label>
                    <input type="file" id="certFile" accept=".crt,.cer,.pem,.txt" multiple>
                    <span id="certFileName" class="file-name-display">No file selected</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>Or Paste Certificate(s):</label>
                <textarea id="certText" placeholder="Paste PEM-encoded certificate(s) here. Multiple certificates can be pasted (leaf certificate first, then intermediates, then root).&#10;&#10;Format:&#10;-----BEGIN CERTIFICATE-----&#10;...&#10;-----END CERTIFICATE-----"></textarea>
            </div>
            
            <div class="button-group">
                <button id="loadCertBtn">Load Certificate(s)</button>
                <button id="addMoreCertBtn" class="copy-button" style="display: none;">Add More Certificates</button>
                <button id="clearCertBtn" class="clear-button">Clear</button>
            </div>
            
            <div id="certMessage"></div>
            <div id="certInfoDisplay"></div>
        </div>
        
        <!-- Private Key Input Section -->
        <div class="section">
            <h3>Step 2: Provide Private Key</h3>
            
            <div class="form-group">
                <label>Private Key File:</label>
                <div class="file-input-wrapper">
                    <label for="keyFile" class="file-input-label">Choose File</label>
                    <input type="file" id="keyFile" accept=".key,.pem,.txt">
                    <span id="keyFileName" class="file-name-display">No file selected</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>Or Paste Private Key:</label>
                <textarea id="keyText" placeholder="Paste PEM-encoded private key here.&#10;&#10;Supported formats:&#10;- RSA PRIVATE KEY (traditional)&#10;- PRIVATE KEY (PKCS#8)&#10;- EC PRIVATE KEY (Elliptic Curve)&#10;- ENCRYPTED PRIVATE KEY (password-protected)"></textarea>
            </div>
            
            <div class="form-group">
                <label>Private Key Password:</label>
                <input type="password" id="keyPassword" placeholder="Leave empty if key is not encrypted" autocomplete="off">
            </div>
            
            <div class="button-group">
                <button id="loadKeyBtn">Load Private Key</button>
                <button id="clearKeyBtn" class="clear-button">Clear</button>
            </div>
            
            <div id="keyMessage"></div>
        </div>
        
        <!-- Chain Validation Section -->
        <div class="section">
            <h3>Step 3: Validate Certificate Chain</h3>
            
            <div id="chainStatus" class="chain-status" style="display: none;">
                <div class="result-label">Chain Status:</div>
                <div id="chainStatusText"></div>
            </div>
            
            <div class="button-group">
                <button id="validateChainBtn">Validate Chain</button>
            </div>
            
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%;">0%</div>
                </div>
            </div>
            
            <div id="chainMessage"></div>
            
            <div id="chainInfoDisplay"></div>
        </div>
        
        <!-- PFX Generation Section -->
        <div class="section">
            <h3>Step 4: Generate PFX Bundle</h3>
            
            <div class="form-group">
                <label>PFX Password:</label>
                <input type="password" id="pfxPassword" placeholder="Enter password to protect PFX file" autocomplete="new-password">
            </div>
            
            <div class="form-group">
                <label>Confirm Password:</label>
                <input type="password" id="pfxPasswordConfirm" placeholder="Re-enter password" autocomplete="new-password">
            </div>
            
            <div class="form-group">
                <label>Friendly Name:</label>
                <input type="text" id="friendlyName" placeholder="Optional: Certificate friendly name for Azure">
            </div>
            
            <div class="button-group">
                <button id="generatePfxBtn">Generate PFX</button>
                <button id="downloadPfxBtn" class="copy-button" style="display: none;">Download PFX File</button>
                <button id="clearPfxBtn" class="clear-button">Clear</button>
            </div>
            
            <div id="pfxMessage"></div>
        </div>
        
        <!-- Information Section -->
        <div class="section">
            <h3 class="collapsible-section" id="aboutToggle">About This Tool</h3>
            
            <div class="collapsible-content" id="aboutContent">
            <div class="example">
                <div class="example-title">Features:</div>
                • <strong>Automatic Chain Validation:</strong> Verifies certificate chain completeness<br>
                • <strong>AIA Fetching:</strong> Automatically downloads missing intermediate and root CA certificates<br>
                • <strong>Local Certificate Store Fallback:</strong> Attempts to find missing certificates from common CA repositories when AIA is unavailable<br>
                • <strong>Multiple Input Formats:</strong> Supports .crt, .cer, .pem, .key files and text paste<br>
                • <strong>Encrypted Key Support:</strong> Handles password-protected private keys<br>
                • <strong>Azure WAF Ready:</strong> Generates PFX files compatible with Azure Application Gateway/WAF<br>
                • <strong>Memory-Only Storage:</strong> All data stored in memory, cleared after download<br>
                • <strong>Client-Side Processing:</strong> 100% browser-based, no server uploads
            </div>
            
            <div class="example">
                <div class="example-title">Supported Certificate Formats:</div>
                • PEM-encoded (.crt, .cer, .pem)<br>
                • Base64-encoded certificates<br>
                • DER-encoded (will be converted automatically)<br>
                • Multiple certificates in single file (chain)
            </div>
            
            <div class="example">
                <div class="example-title">Supported Private Key Formats:</div>
                • RSA Private Key (-----BEGIN RSA PRIVATE KEY-----)<br>
                • PKCS#8 Private Key (-----BEGIN PRIVATE KEY-----)<br>
                • EC Private Key (-----BEGIN EC PRIVATE KEY-----)<br>
                • Encrypted Private Key (-----BEGIN ENCRYPTED PRIVATE KEY-----)
            </div>
            
            <div class="example">
                <div class="example-title">Usage Instructions:</div>
                1. <strong>Load Certificate:</strong> Upload your certificate file or paste the PEM-encoded certificate<br>
                2. <strong>Load Private Key:</strong> Upload your private key file or paste it (provide password if encrypted)<br>
                3. <strong>Validate Chain:</strong> Check if certificate chain is complete. Add missing intermediate/root certificates if needed<br>
                4. <strong>Generate PFX:</strong> Set a strong password and generate the PFX bundle<br>
                5. <strong>Download:</strong> Download the PFX file and upload it to Azure Portal
            </div>
            </div>
        </div>
        
                </div>
            </div>
            
            <!-- Right Column: Check PFX Bundle -->
            <div class="column">
                <div class="column-header checker">Check PFX Bundle</div>
                <div class="column-content checker">
                
        <!-- PFX Upload Section -->
        <div class="section">
            <h3>Upload PFX Bundle</h3>
            
            <div class="form-group">
                <label>PFX/PKCS#12 File:</label>
                <div class="file-input-wrapper">
                    <label for="checkPfxFile" class="file-input-label">Choose PFX File</label>
                    <input type="file" id="checkPfxFile" accept=".pfx,.p12">
                    <span id="checkPfxFileName" class="file-name-display">No file selected</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>PFX Password:</label>
                <input type="password" id="checkPfxPassword" placeholder="Enter PFX password" autocomplete="off">
            </div>
            
            <div class="button-group">
                <button id="checkPfxBtn" class="copy-button">Check PFX Bundle</button>
                <button id="clearCheckBtn" class="clear-button">Clear</button>
            </div>
            
            <div id="checkMessage"></div>
        </div>
        
        <!-- PFX Contents Display -->
        <div class="section">
            <h3>PFX Bundle Contents</h3>
            <div id="pfxContentsDisplay"></div>
        </div>
        
        <!-- PFX Chain Validation -->
        <div class="section">
            <h3>Certificate Chain Validation</h3>
            
            <div id="pfxChainStatus" class="chain-status" style="display: none;">
                <div class="result-label">Chain Status:</div>
                <div id="pfxChainStatusText"></div>
            </div>
            
            <div id="pfxChainMessage"></div>
        </div>
        
                </div>
            </div>
        </div>
    </div>

    <!-- Include forge.js for cryptographic operations -->
    <!-- Try CDN first, then fall back to local copy -->
    <script>
        // Load forge.js with fallback mechanism
        (function() {
            var cdnScript = document.createElement('script');
            cdnScript.src = 'https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js';
            cdnScript.crossOrigin = 'anonymous';
            
            cdnScript.onerror = function() {
                console.warn('CDN unavailable, loading local forge.js');
                var localScript = document.createElement('script');
                localScript.src = 'forge.min.js';
                localScript.onerror = function() {
                    console.error('Failed to load forge.js from both CDN and local source');
                    document.addEventListener('DOMContentLoaded', function() {
                        alert('Critical Error: Could not load required cryptographic library. Please ensure forge.min.js is available locally or check your internet connection.');
                    });
                };
                document.head.appendChild(localScript);
            };
            
            document.head.appendChild(cdnScript);
        })();
    </script>
    
    <script>
        /**
         * PFX Certificate Bundle Generator
         * 
         * Features:
         * - Automatic certificate chain validation
         * - AIA (Authority Information Access) fetching for missing intermediates
         * - Multiple input format support (PEM, DER, various key formats)
         * - Encrypted private key support
         * - Memory-only storage with automatic cleanup
         * - Azure WAF/Application Gateway ready
         * 
         * Created by Aleksandr Sukhov on December 7, 2025
         * 
         * @version 1.0.0
         */
        
        'use strict';
        
        // Wait for both DOM and forge.js to be ready
        function initializeApp() {
            // Check if forge is available
            if (typeof forge === 'undefined') {
                console.warn('Waiting for forge.js to load...');
                setTimeout(initializeApp, 100);
                return;
            }
            
            const PFXGenerator = (() => {
                // DOM Elements
                const DOM = {
                    // Certificate inputs
                    certFile: document.getElementById('certFile'),
                    certText: document.getElementById('certText'),
                    certFileName: document.getElementById('certFileName'),
                    loadCertBtn: document.getElementById('loadCertBtn'),
                    addMoreCertBtn: document.getElementById('addMoreCertBtn'),
                    clearCertBtn: document.getElementById('clearCertBtn'),
                    certMessage: document.getElementById('certMessage'),
                    certInfoDisplay: document.getElementById('certInfoDisplay'),
                    
                    // Private key inputs
                    keyFile: document.getElementById('keyFile'),
                    keyText: document.getElementById('keyText'),
                    keyFileName: document.getElementById('keyFileName'),
                    keyPassword: document.getElementById('keyPassword'),
                    loadKeyBtn: document.getElementById('loadKeyBtn'),
                    clearKeyBtn: document.getElementById('clearKeyBtn'),
                    keyMessage: document.getElementById('keyMessage'),
                    
                    // Chain validation
                    validateChainBtn: document.getElementById('validateChainBtn'),
                    fetchIntermediatesBtn: document.getElementById('fetchIntermediatesBtn'),
                    chainStatus: document.getElementById('chainStatus'),
                    chainStatusText: document.getElementById('chainStatusText'),
                    chainMessage: document.getElementById('chainMessage'),
                    chainInfoDisplay: document.getElementById('chainInfoDisplay'),
                    progressContainer: document.getElementById('progressContainer'),
                    progressFill: document.getElementById('progressFill'),
                    
                    // PFX generation
                    pfxPassword: document.getElementById('pfxPassword'),
                    pfxPasswordConfirm: document.getElementById('pfxPasswordConfirm'),
                    friendlyName: document.getElementById('friendlyName'),
                    generatePfxBtn: document.getElementById('generatePfxBtn'),
                    downloadPfxBtn: document.getElementById('downloadPfxBtn'),
                    clearPfxBtn: document.getElementById('clearPfxBtn'),
                    pfxMessage: document.getElementById('pfxMessage'),
                    
                    // Security
                    clearAllBtn: document.getElementById('clearAllBtn'),
                    securityToggleBtn: document.getElementById('securityToggleBtn'),
                    securityReport: document.getElementById('securityReport'),
                    securityDetails: document.getElementById('securityDetails'),
                    
                    // PFX Checker
                    checkPfxFile: document.getElementById('checkPfxFile'),
                    checkPfxFileName: document.getElementById('checkPfxFileName'),
                    checkPfxPassword: document.getElementById('checkPfxPassword'),
                    checkPfxBtn: document.getElementById('checkPfxBtn'),
                    clearCheckBtn: document.getElementById('clearCheckBtn'),
                    checkMessage: document.getElementById('checkMessage'),
                    pfxContentsDisplay: document.getElementById('pfxContentsDisplay'),
                    pfxChainStatus: document.getElementById('pfxChainStatus'),
                    pfxChainStatusText: document.getElementById('pfxChainStatusText'),
                    pfxChainMessage: document.getElementById('pfxChainMessage')
                };
                
                // Application state
                const state = {
                    certificates: [],
                    privateKey: null,
                    pfxData: null,
                    chainComplete: false,
                    pfxFileName: 'certificate.pfx',
                    corsBlockedUrls: []
                };
                
                /**
                 * Initialize the application
                 */
                const init = () => {
                    try {
                        // Check for forge.js
                        if (typeof forge === 'undefined') {
                            showMessage('certMessage', 'Error: Cryptographic library not loaded. Please refresh the page or ensure forge.min.js is available locally.', 'error');
                            return;
                        }
                        
                        setupEventListeners();
                        initSecurityFeatures();
                        setupCollapsibleSections();
                        
                        console.info('PFX Generator initialized successfully');
                    } catch (error) {
                        console.error('Initialization error:', error);
                        showMessage('certMessage', 'Error initializing application: ' + error.message, 'error');
                    }
                };
                
                /**
                 * Setup event listeners
                 */
                const setupEventListeners = () => {
                    // Certificate events
                    DOM.certFile.addEventListener('change', handleCertFileChange);
                    DOM.loadCertBtn.addEventListener('click', () => loadCertificates(false));
                    DOM.addMoreCertBtn.addEventListener('click', () => loadCertificates(true));
                    DOM.clearCertBtn.addEventListener('click', clearCertificates);
                    
                    // Private key events
                    DOM.keyFile.addEventListener('change', handleKeyFileChange);
                    DOM.loadKeyBtn.addEventListener('click', loadPrivateKey);
                    DOM.clearKeyBtn.addEventListener('click', clearPrivateKey);
                    
                    // Chain validation events
                    DOM.validateChainBtn.addEventListener('click', validateChain);
                    
                    // PFX generation events
                    DOM.generatePfxBtn.addEventListener('click', generatePFX);
                    DOM.downloadPfxBtn.addEventListener('click', downloadPFX);
                    DOM.clearPfxBtn.addEventListener('click', clearPFXData);
                    
                    // Security events
                    DOM.clearAllBtn.addEventListener('click', clearAll);
                    DOM.securityToggleBtn.addEventListener('click', toggleSecurityStatus);
                    
                    // PFX Checker events
                    DOM.checkPfxFile.addEventListener('change', handleCheckPfxFileChange);
                    DOM.checkPfxBtn.addEventListener('click', checkPfxBundle);
                    DOM.clearCheckBtn.addEventListener('click', clearPfxChecker);
                    
                    // Cleanup on page unload
                    window.addEventListener('beforeunload', cleanup);
                };
                
                /**
                 * Initialize security features
                 */
                const initSecurityFeatures = () => {
                    // Check HTTPS
                    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                        showMessage('certMessage', 'Warning: This page should be served over HTTPS for security.', 'warning');
                    }
                };
                
                /**
                 * Setup collapsible sections
                 */
                const setupCollapsibleSections = () => {
                    const aboutToggle = document.getElementById('aboutToggle');
                    const aboutContent = document.getElementById('aboutContent');
                    
                    if (aboutToggle && aboutContent) {
                        aboutToggle.addEventListener('click', () => {
                            aboutToggle.classList.toggle('expanded');
                            aboutContent.classList.toggle('show');
                        });
                    }
                };
                
                /**
                 * Toggle Security Status display
                 */
                const toggleSecurityStatus = () => {
                    if (DOM.securityReport.style.display === 'none') {
                        performSecurityCheck();
                        DOM.securityReport.style.display = 'block';
                    } else {
                        DOM.securityReport.style.display = 'none';
                    }
                };
                
                /**
                 * Handle certificate file selection
                 */
                const handleCertFileChange = (e) => {
                    const files = e.target.files;
                    if (files.length > 0) {
                        const fileNames = Array.from(files).map(f => f.name).join(', ');
                        DOM.certFileName.textContent = fileNames;
                    } else {
                        DOM.certFileName.textContent = 'No file selected';
                    }
                };
                
                /**
                 * Handle private key file selection
                 */
                const handleKeyFileChange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        DOM.keyFileName.textContent = file.name;
                    } else {
                        DOM.keyFileName.textContent = 'No file selected';
                    }
                };
                
                /**
                 * @param {boolean} appendMode - If true, append to existing certificates; if false, replace
                 */
                const loadCertificates = async (appendMode = false) => {
                    try {
                        const loadingBtn = appendMode ? DOM.addMoreCertBtn : DOM.loadCertBtn;
                        showLoading(loadingBtn);
                        clearMessage('certMessage');
                        
                        let certPemData = DOM.certText.value.trim();
                        
                        // Load from file if no text provided
                        if (!certPemData && DOM.certFile.files.length > 0) {
                            const files = Array.from(DOM.certFile.files);
                            const fileContents = await Promise.all(files.map(file => readFileAsCertificate(file)));
                            certPemData = fileContents.join('\n');
                        }
                        
                        if (!certPemData) {
                            showMessage('certMessage', 'Please provide a certificate file or paste certificate text.', 'warning');
                            return;
                        }
                        
                        // Parse new certificates
                        const newCerts = parseCertificates(certPemData);
                        
                        if (newCerts.length === 0) {
                            showMessage('certMessage', 'No valid certificates found in input.', 'error');
                            return;
                        }
                        
                        // Append or replace certificates
                        if (appendMode && state.certificates.length > 0) {
                            console.info(`Appending ${newCerts.length} certificate(s) to existing ${state.certificates.length} certificate(s)`);
                            
                            // Merge certificates, avoiding duplicates based on fingerprint
                            const existingFingerprints = new Set(state.certificates.map(c => c.fingerprint));
                            let addedCount = 0;
                            
                            newCerts.forEach(newCert => {
                                if (!existingFingerprints.has(newCert.fingerprint)) {
                                    state.certificates.push(newCert);
                                    addedCount++;
                                } else {
                                    console.info('Skipping duplicate certificate:', newCert.subject);
                                }
                            });
                            
                            if (addedCount === 0) {
                                showMessage('certMessage', 'No new certificates added (all were duplicates).', 'warning');
                                return;
                            }
                            
                            // Sort the combined set
                            state.certificates = sortCertificates(state.certificates);
                            
                            displayCertificateInfo(state.certificates);
                            showMessage('certMessage', `Added ${addedCount} new certificate(s). Total: ${state.certificates.length}. Certificates have been automatically re-sorted.`, 'success');
                        } else {
                            // Replace mode
                            state.certificates = newCerts;
                            
                            // Sort certificates: leaf first, then intermediates, then root
                            state.certificates = sortCertificates(state.certificates);
                            
                            // Display certificate information
                            displayCertificateInfo(state.certificates);
                            showMessage('certMessage', `Successfully loaded ${state.certificates.length} certificate(s). Certificates have been automatically sorted (leaf → intermediate → root).`, 'success');
                        }
                        
                        // Show "Add More" button when certificates are loaded (always show if we have certs)
                        if (state.certificates.length > 0) {
                            DOM.addMoreCertBtn.style.display = 'inline-block';
                        }
                        
                        // Clear file input and text area for next addition
                        DOM.certFile.value = '';
                        DOM.certFileName.textContent = 'No file selected';
                        DOM.certText.value = '';
                        
                    } catch (error) {
                        console.error('Error loading certificates:', error);
                        showMessage('certMessage', 'Error loading certificates: ' + error.message, 'error');
                    } finally {
                        hideLoading(appendMode ? DOM.addMoreCertBtn : DOM.loadCertBtn);
                    }
                };
                
                /**
                 * Sort certificates in correct order: leaf → intermediate → root
                 */
                const sortCertificates = (certs) => {
                    if (certs.length <= 1) return certs;
                    
                    console.info('Sorting certificates by chain order...');
                    
                    // Build a map for quick lookup
                    const certMap = new Map();
                    certs.forEach(cert => {
                        certMap.set(cert.subject, cert);
                    });
                    
                    // Identify the leaf certificate (one that is not an issuer of any other cert)
                    const issuers = new Set(certs.map(c => c.issuer));
                    const leafCerts = certs.filter(cert => !issuers.has(cert.subject) || cert.subject === cert.issuer);
                    
                    // If we can't determine the leaf clearly, use the first non-self-signed cert
                    let leafCert = leafCerts.find(c => c.subject !== c.issuer);
                    if (!leafCert && leafCerts.length > 0) {
                        leafCert = leafCerts[0];
                    }
                    if (!leafCert) {
                        leafCert = certs.find(c => c.subject !== c.issuer) || certs[0];
                    }
                    
                    // Build the chain starting from leaf
                    const sortedCerts = [];
                    const processed = new Set();
                    let currentCert = leafCert;
                    
                    while (currentCert && !processed.has(currentCert.subject)) {
                        sortedCerts.push(currentCert);
                        processed.add(currentCert.subject);
                        
                        // Find the issuer
                        if (currentCert.subject === currentCert.issuer) {
                            // Self-signed (root), we're done
                            break;
                        }
                        
                        currentCert = certMap.get(currentCert.issuer);
                    }
                    
                    // Add any remaining certificates that weren't in the chain
                    certs.forEach(cert => {
                        if (!processed.has(cert.subject)) {
                            sortedCerts.push(cert);
                        }
                    });
                    
                    console.info('Certificate order:', sortedCerts.map((c, i) => {
                        const type = c.subject === c.issuer ? 'Root' : (i === 0 ? 'Leaf' : 'Intermediate');
                        return `${i + 1}. ${type}: ${c.subject}`;
                    }).join('\n'));
                    
                    return sortedCerts;
                };
                
                /**
                 * Parse PEM-encoded certificates
                 */
                const parseCertificates = (pemData) => {
                    const certs = [];
                    
                    try {
                        // Extract all certificate blocks
                        const certRegex = /-----BEGIN CERTIFICATE-----[\s\S]+?-----END CERTIFICATE-----/g;
                        const certMatches = pemData.match(certRegex);
                        
                        if (!certMatches) {
                            throw new Error('No PEM-encoded certificates found');
                        }
                        
                        for (const certPem of certMatches) {
                            try {
                                const cert = forge.pki.certificateFromPem(certPem);
                                certs.push({
                                    pem: certPem,
                                    cert: cert,
                                    subject: cert.subject.attributes.map(attr => `${attr.shortName}=${attr.value}`).join(', '),
                                    issuer: cert.issuer.attributes.map(attr => `${attr.shortName}=${attr.value}`).join(', '),
                                    serialNumber: cert.serialNumber,
                                    notBefore: cert.validity.notBefore,
                                    notAfter: cert.validity.notAfter,
                                    fingerprint: forge.md.sha256.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex()
                                });
                            } catch (error) {
                                console.warn('Failed to parse certificate:', error);
                            }
                        }
                        
                    } catch (error) {
                        throw new Error('Failed to parse certificates: ' + error.message);
                    }
                    
                    return certs;
                };
                
                /**
                 * Format hex string with colons every 2 characters
                 */
                const formatHexWithColons = (hexString) => {
                    return hexString.toUpperCase().match(/.{1,2}/g).join(':');
                };
                
                /**
                 * Get root certificate download link for CA provider
                 */
                const getRootCertDownloadLinks = (subject, issuer) => {
                    const links = [];
                    const text = (subject + issuer).toLowerCase();
                    
                    if (text.includes('globalsign')) {
                        links.push({
                            name: 'GlobalSign Root Certificates',
                            url: 'https://support.globalsign.com/ca-certificates/globalsign-root-certificates'
                        });
                    }
                    if (text.includes('digicert')) {
                        links.push({
                            name: 'DigiCert Root Certificates',
                            url: 'https://www.digicert.com/kb/digicert-root-certificates.htm'
                        });
                    }
                    if (text.includes('sectigo') || text.includes('comodo')) {
                        links.push({
                            name: 'Sectigo Root Certificates',
                            url: 'https://www.sectigo.com/knowledge-base/detail/Sectigo-Intermediate-Certificates/kA01N000000rfBO'
                        });
                    }
                    if (text.includes('lets encrypt') || text.includes('letsencrypt')) {
                        links.push({
                            name: "Let's Encrypt Root Certificates",
                            url: 'https://letsencrypt.org/certificates/'
                        });
                    }
                    if (text.includes('godaddy')) {
                        links.push({
                            name: 'GoDaddy Root Certificates',
                            url: 'https://www.godaddy.com/help/download-root-and-intermediate-certificates-16054'
                        });
                    }
                    if (text.includes('entrust')) {
                        links.push({
                            name: 'Entrust Root Certificates',
                            url: 'https://www.entrust.com/resources/certificate-solutions/certificates'
                        });
                    }
                    if (text.includes('geotrust') || text.includes('thawte') || text.includes('rapidssl')) {
                        links.push({
                            name: 'GeoTrust/Thawte/RapidSSL Root Certificates',
                            url: 'https://knowledge.digicert.com/generalinformation/INFO1548.html'
                        });
                    }
                    if (text.includes('microsoft') || text.includes('windows')) {
                        links.push({
                            name: 'Microsoft Root Certificates',
                            url: 'https://www.microsoft.com/pki/mscorp/cps'
                        });
                    }
                    
                    return links;
                };
                
                /**
                 * Display certificate information
                 */
                const displayCertificateInfo = (certificates) => {
                    let html = '<div class="cert-info"><div class="cert-info-title">Loaded Certificates:</div>';
                    
                    certificates.forEach((certInfo, index) => {
                        const isSelfSigned = certInfo.subject === certInfo.issuer;
                        const certType = isSelfSigned ? 'Root CA' : (index === 0 ? 'Leaf Certificate' : 'Intermediate CA');
                        
                        // Extract AIA information
                        const aiaInfo = extractAIAUrls(certInfo.cert);
                        
                        html += `
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc;">
                                <strong>Certificate ${index + 1} (${certType}):</strong><br>
                                Subject: ${certInfo.subject}<br>
                                Issuer: ${certInfo.issuer}<br>`;
                        
                        // For root certificates or certificates without AIA, show formatted serial and thumbprint
                        if (isSelfSigned || (aiaInfo.caIssuers.length === 0 && aiaInfo.ocsp.length === 0)) {
                            html += `Serial: ${formatHexWithColons(certInfo.serialNumber)}<br>`;
                        } else {
                            html += `Serial: ${certInfo.serialNumber}<br>`;
                        }
                        
                        html += `Valid: ${certInfo.notBefore.toLocaleDateString()} - ${certInfo.notAfter.toLocaleDateString()}<br>`;
                        
                        // For root certificates or certificates without AIA, show formatted thumbprint
                        if (isSelfSigned || (aiaInfo.caIssuers.length === 0 && aiaInfo.ocsp.length === 0)) {
                            html += `SHA-256 Thumbprint: ${formatHexWithColons(certInfo.fingerprint)}`;
                        } else {
                            html += `SHA-256: ${certInfo.fingerprint}`;
                        }
                        
                        // Add AIA information if available
                        if (aiaInfo.caIssuers.length > 0 || aiaInfo.ocsp.length > 0) {
                            html += '<br><strong>AIA Extensions:</strong><br>';
                            if (aiaInfo.caIssuers.length > 0) {
                                html += '&nbsp;&nbsp;CA Issuers URLs:<br>';
                                aiaInfo.caIssuers.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href="${url}" target="_blank" style="color: #2196F3;">${url}</a><br>`;
                                });
                            }
                            if (aiaInfo.ocsp.length > 0) {
                                html += '&nbsp;&nbsp;OCSP URLs:<br>';
                                aiaInfo.ocsp.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href="${url}" target="_blank" style="color: #2196F3;">${url}</a><br>`;
                                });
                            }
                        } else if (isSelfSigned) {
                            // Show root certificate download links
                            const rootLinks = getRootCertDownloadLinks(certInfo.subject, certInfo.issuer);
                            if (rootLinks.length > 0) {
                                html += '<br><strong>Download Root Certificate:</strong><br>';
                                rootLinks.forEach(link => {
                                    html += `&nbsp;&nbsp;• <a href="${link.url}" target="_blank" style="color: #4CAF50;">${link.name}</a><br>`;
                                });
                            }
                        }
                        
                        html += `
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    DOM.certInfoDisplay.innerHTML = html;
                };
                
                /**
                 * Load private key from file or text
                 */
                const loadPrivateKey = async () => {
                    try {
                        showLoading(DOM.loadKeyBtn);
                        clearMessage('keyMessage');
                        
                        let keyPemData = DOM.keyText.value.trim();
                        
                        // Load from file if no text provided
                        if (!keyPemData && DOM.keyFile.files.length > 0) {
                            keyPemData = await readFileAsText(DOM.keyFile.files[0]);
                        }
                        
                        if (!keyPemData) {
                            showMessage('keyMessage', 'Please provide a private key file or paste private key text.', 'warning');
                            return;
                        }
                        
                        // Parse private key
                        const password = DOM.keyPassword.value;
                        state.privateKey = parsePrivateKey(keyPemData, password);
                        
                        showMessage('keyMessage', 'Successfully loaded private key.', 'success');
                        
                        // Verify key matches certificate if both are loaded
                        if (state.certificates.length > 0) {
                            verifyKeyMatchesCertificate();
                        }
                        
                    } catch (error) {
                        console.error('Error loading private key:', error);
                        showMessage('keyMessage', 'Error loading private key: ' + error.message, 'error');
                        state.privateKey = null;
                    } finally {
                        hideLoading(DOM.loadKeyBtn);
                    }
                };
                
                /**
                 * Parse PEM-encoded private key
                 */
                const parsePrivateKey = (pemData, password) => {
                    try {
                        // Try to decrypt if password provided
                        if (password && pemData.includes('ENCRYPTED')) {
                            return forge.pki.decryptRsaPrivateKey(pemData, password);
                        }
                        
                        // Try different key formats
                        if (pemData.includes('RSA PRIVATE KEY')) {
                            return forge.pki.privateKeyFromPem(pemData);
                        } else if (pemData.includes('PRIVATE KEY')) {
                            return forge.pki.privateKeyFromPem(pemData);
                        } else if (pemData.includes('EC PRIVATE KEY')) {
                            // For EC keys, we need different handling
                            throw new Error('EC private keys are not fully supported yet. Please convert to PKCS#8 format.');
                        } else {
                            throw new Error('Unrecognized private key format');
                        }
                        
                    } catch (error) {
                        if (error.message.includes('decrypt') || error.message.includes('password')) {
                            throw new Error('Failed to decrypt private key. Please check the password.');
                        }
                        throw new Error('Failed to parse private key: ' + error.message);
                    }
                };
                
                /**
                 * Verify private key matches certificate
                 */
                const verifyKeyMatchesCertificate = () => {
                    try {
                        if (!state.privateKey || state.certificates.length === 0) {
                            return;
                        }
                        
                        const cert = state.certificates[0].cert;
                        const publicKey = cert.publicKey;
                        
                        // Compare modulus for RSA keys
                        if (state.privateKey.n && publicKey.n) {
                            if (state.privateKey.n.toString() === publicKey.n.toString()) {
                                showMessage('keyMessage', 'Private key matches the certificate. ✓', 'success');
                            } else {
                                showMessage('keyMessage', 'Warning: Private key does not match the certificate!', 'error');
                            }
                        }
                        
                    } catch (error) {
                        console.warn('Could not verify key match:', error);
                    }
                };
                
                /**
                 * Validate certificate chain
                 */
                const validateChain = async () => {
                    try {
                        showLoading(DOM.validateChainBtn);
                        clearMessage('chainMessage');
                        DOM.chainStatus.style.display = 'block';
                        
                        if (state.certificates.length === 0) {
                            showMessage('chainMessage', 'Please load certificates first.', 'warning');
                            return;
                        }
                        
                        // Build chain validation
                        const chainAnalysis = analyzeChain(state.certificates);
                        
                        // Display chain status
                        displayChainStatus(chainAnalysis);
                        
                        state.chainComplete = chainAnalysis.complete;
                        
                        if (chainAnalysis.complete) {
                            showMessage('chainMessage', 'Certificate chain is complete and valid! ✓', 'success');
                        } else {
                            showMessage('chainMessage', `Chain incomplete. Missing ${chainAnalysis.missingCount} intermediate certificate(s). See chain analysis below for download links.`, 'warning');
                        }
                        
                    } catch (error) {
                        console.error('Error validating chain:', error);
                        showMessage('chainMessage', 'Error validating chain: ' + error.message, 'error');
                    } finally {
                        hideLoading(DOM.validateChainBtn);
                    }
                };
                
                /**
                 * Analyze certificate chain
                 */
                const analyzeChain = (certificates) => {
                    const analysis = {
                        complete: false,
                        missingCount: 0,
                        missingIssuers: [],
                        chainDetails: []
                    };
                    
                    try {
                        for (let i = 0; i < certificates.length; i++) {
                            const cert = certificates[i];
                            const isSelfSigned = cert.subject === cert.issuer;
                            
                            // Extract AIA information
                            const aiaInfo = extractAIAUrls(cert.cert);
                            
                            analysis.chainDetails.push({
                                index: i,
                                subject: cert.subject,
                                issuer: cert.issuer,
                                isSelfSigned: isSelfSigned,
                                hasIssuerInChain: false,
                                aiaInfo: aiaInfo
                            });
                            
                            // Check if issuer is in chain
                            if (!isSelfSigned) {
                                const issuerFound = certificates.some(c => c.subject === cert.issuer);
                                analysis.chainDetails[i].hasIssuerInChain = issuerFound;
                                
                                if (!issuerFound) {
                                    analysis.missingCount++;
                                    analysis.missingIssuers.push(cert.issuer);
                                }
                            }
                        }
                        
                        // Chain is complete if no missing issuers
                        analysis.complete = analysis.missingCount === 0;
                        
                    } catch (error) {
                        console.error('Error analyzing chain:', error);
                    }
                    
                    return analysis;
                };
                
                /**
                 * Display chain status
                 */
                const displayChainStatus = (analysis) => {
                    const statusClass = analysis.complete ? 'chain-complete' : 'chain-incomplete';
                    DOM.chainStatus.className = `chain-status ${statusClass}`;
                    
                    let html = `<strong>Chain Analysis:</strong><br>`;
                    html += `Total Certificates: ${analysis.chainDetails.length}<br>`;
                    html += `Missing Intermediates: ${analysis.missingCount}<br><br>`;
                    
                    analysis.chainDetails.forEach((detail, idx) => {
                        const status = detail.isSelfSigned ? '✓ Root CA' : (detail.hasIssuerInChain ? '✓ Valid' : '✗ Issuer missing');
                        html += `[${detail.index + 1}] ${status}: ${detail.subject}<br>`;
                        
                        // Show certificate details (serial and thumbprint)
                        const cert = state.certificates[idx];
                        if (cert) {
                            html += `&nbsp;&nbsp;&nbsp;&nbsp;Serial: ${formatHexWithColons(cert.serialNumber)}<br>`;
                            html += `&nbsp;&nbsp;&nbsp;&nbsp;SHA-256: ${formatHexWithColons(cert.fingerprint)}<br>`;
                        }
                        
                        // Add AIA information for missing issuers
                        if (!detail.isSelfSigned && !detail.hasIssuerInChain && detail.aiaInfo) {
                            if (detail.aiaInfo.caIssuers.length > 0) {
                                html += `&nbsp;&nbsp;&nbsp;&nbsp;<strong>CA Issuer URLs available for fetching:</strong><br>`;
                                detail.aiaInfo.caIssuers.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• <a href="${url}" target="_blank" style="color: #2196F3;">${url}</a><br>`;
                                });
                            } else {
                                html += `&nbsp;&nbsp;&nbsp;&nbsp;⚠ No CA Issuer URLs in AIA extension<br>`;
                                
                                // Show root certificate download links if this looks like a known CA
                                const rootLinks = getRootCertDownloadLinks(detail.subject, detail.issuer);
                                if (rootLinks.length > 0) {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;<strong>Download from CA:</strong><br>`;
                                    rootLinks.forEach(link => {
                                        html += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• <a href="${link.url}" target="_blank" style="color: #4CAF50;">${link.name}</a><br>`;
                                    });
                                }
                            }
                        }
                    });
                    
                    if (analysis.missingIssuers.length > 0) {
                        html += `<br><strong>Missing Issuers:</strong><br>`;
                        analysis.missingIssuers.forEach((issuer, idx) => {
                            html += `• ${issuer}<br>`;
                            
                            // Show root certificate download links for missing issuers
                            const rootLinks = getRootCertDownloadLinks(issuer, issuer);
                            if (rootLinks.length > 0) {
                                html += `&nbsp;&nbsp;<strong>Download from CA:</strong><br>`;
                                rootLinks.forEach(link => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href="${link.url}" target="_blank" style="color: #4CAF50;">${link.name}</a><br>`;
                                });
                            }
                        });
                        
                        html += `<br><div style="background-color: #fff3e0; padding: 10px; border-left: 3px solid #ff9800; margin-top: 10px;">`;
                        html += `<strong>📋 How to Complete the Certificate Chain:</strong><br><br>`;
                        html += `<strong>Step 1:</strong> Download missing certificates<br>`;
                        html += `&nbsp;&nbsp;• Click the CA Issuer URLs or CA download links above<br>`;
                        html += `&nbsp;&nbsp;• Save the certificate files to your computer (.crt, .cer, or .pem format)<br><br>`;
                        html += `<strong>Step 2:</strong> Add the certificates to this tool<br>`;
                        html += `&nbsp;&nbsp;• Go back to <strong>Step 1</strong> and click the <strong>"Add More Certificates"</strong> button<br>`;
                        html += `&nbsp;&nbsp;• Load the downloaded intermediate/root certificates<br>`;
                        html += `&nbsp;&nbsp;• The tool will automatically detect and prevent duplicates<br><br>`;
                        html += `<strong>Step 3:</strong> Validate again<br>`;
                        html += `&nbsp;&nbsp;• Return to this section and click <strong>"Validate Chain"</strong><br>`;
                        html += `&nbsp;&nbsp;• Repeat until the chain is complete<br>`;
                        html += `</div>`;
                    }
                    
                    DOM.chainStatusText.innerHTML = html;
                };
                
                /**
                 * Extract AIA URLs from certificate
                 */
                const extractAIAUrls = (cert) => {
                    const urls = {
                        caIssuers: [],
                        ocsp: []
                    };
                    
                    try {
                        // Look for Authority Information Access extension
                        const aiaExt = cert.extensions.find(ext => 
                            ext.id === '1.3.6.1.5.5.7.1.1' || ext.name === 'authorityInfoAccess'
                        );
                        
                        if (!aiaExt) {
                            return urls;
                        }
                        
                        // Parse the ASN.1 structure of AIA extension
                        // AIA is a SEQUENCE of AccessDescription
                        // Each AccessDescription is a SEQUENCE containing:
                        //   - accessMethod (OID)
                        //   - accessLocation (GeneralName)
                        
                        try {
                            // The extension value is DER encoded
                            const der = forge.util.createBuffer(aiaExt.value, 'raw');
                            const asn1 = forge.asn1.fromDer(der);
                            
                            // Iterate through the SEQUENCE
                            if (asn1.value && Array.isArray(asn1.value)) {
                                for (const accessDesc of asn1.value) {
                                    if (accessDesc.value && Array.isArray(accessDesc.value) && accessDesc.value.length >= 2) {
                                        const accessMethod = accessDesc.value[0];
                                        const accessLocation = accessDesc.value[1];
                                        
                                        // Get OID value
                                        let oid = '';
                                        if (accessMethod.value) {
                                            oid = forge.asn1.derToOid(accessMethod.value);
                                        }
                                        
                                        // Get URL from accessLocation
                                        let url = '';
                                        if (accessLocation.value) {
                                            if (typeof accessLocation.value === 'string') {
                                                url = accessLocation.value;
                                            } else if (accessLocation.value instanceof forge.util.ByteStringBuffer) {
                                                url = accessLocation.value.toString();
                                            }
                                        }
                                        
                                        // Classify by OID
                                        // 1.3.6.1.5.5.7.48.1 = OCSP
                                        // 1.3.6.1.5.5.7.48.2 = CA Issuers
                                        if (oid === '1.3.6.1.5.5.7.48.2' && url) {
                                            console.info('Found CA Issuer URL:', url);
                                            urls.caIssuers.push(url);
                                        } else if (oid === '1.3.6.1.5.5.7.48.1' && url) {
                                            console.info('Found OCSP URL:', url);
                                            urls.ocsp.push(url);
                                        } else if (oid) {
                                            console.info('Found unknown AIA OID:', oid, 'URL:', url);
                                        }
                                    }
                                }
                            }
                        } catch (asnError) {
                            // Fallback to regex-based parsing if ASN.1 parsing fails
                            console.warn('ASN.1 parsing failed, falling back to regex:', asnError);
                            if (aiaExt.value) {
                                const matches = aiaExt.value.match(/https?:\/\/[^\s\x00-\x1f"<>]+/gi);
                                if (matches) {
                                    for (const url of matches) {
                                        // Try to classify based on URL content
                                        if (url.toLowerCase().includes('ocsp')) {
                                            urls.ocsp.push(url);
                                        } else if (url.endsWith('.crt') || url.endsWith('.cer') || 
                                                   url.toLowerCase().includes('cacert') || 
                                                   url.toLowerCase().includes('issuer')) {
                                            urls.caIssuers.push(url);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Error extracting AIA URLs:', error);
                    }
                    
                    return urls;
                };
                
                /**
                 * Generate PFX file
                 */
                const generatePFX = async () => {
                    try {
                        showLoading(DOM.generatePfxBtn);
                        clearMessage('pfxMessage');
                        
                        // Validate inputs
                        if (state.certificates.length === 0) {
                            showMessage('pfxMessage', 'Please load certificates first.', 'warning');
                            return;
                        }
                        
                        if (!state.privateKey) {
                            showMessage('pfxMessage', 'Please load private key first.', 'warning');
                            return;
                        }
                        
                        const password = DOM.pfxPassword.value;
                        const passwordConfirm = DOM.pfxPasswordConfirm.value;
                        
                        if (!password) {
                            showMessage('pfxMessage', 'Please enter a password to protect the PFX file.', 'warning');
                            return;
                        }
                        
                        if (password !== passwordConfirm) {
                            showMessage('pfxMessage', 'Passwords do not match.', 'error');
                            return;
                        }
                        
                        if (password.length < 8) {
                            showMessage('pfxMessage', 'Password should be at least 8 characters long.', 'warning');
                        }
                        
                        // Warn if chain is incomplete
                        if (!state.chainComplete) {
                            if (!confirm('Certificate chain appears incomplete. Continue anyway?')) {
                                return;
                            }
                        }
                        
                        showMessage('pfxMessage', 'Generating PFX file...', 'info');
                        
                        // Create PKCS#12 bundle
                        const p12Asn1 = createPKCS12(
                            state.privateKey,
                            state.certificates.map(c => c.cert),
                            password,
                            DOM.friendlyName.value || 'Azure WAF Certificate'
                        );
                        
                        // Convert to DER
                        const p12Der = forge.asn1.toDer(p12Asn1).getBytes();
                        
                        // Store PFX data
                        state.pfxData = forge.util.encode64(p12Der);
                        
                        // Extract CN from certificate for filename
                        const cn = state.certificates[0].cert.subject.getField('CN');
                        state.pfxFileName = cn ? `${cn.value}.pfx` : 'certificate.pfx';
                        
                        showMessage('pfxMessage', 'PFX file generated successfully! Click "Download" to save.', 'success');
                        DOM.downloadPfxBtn.style.display = 'inline-block';
                        
                    } catch (error) {
                        console.error('Error generating PFX:', error);
                        showMessage('pfxMessage', 'Error generating PFX: ' + error.message, 'error');
                    } finally {
                        hideLoading(DOM.generatePfxBtn);
                    }
                };
                
                /**
                 * Create PKCS#12 structure
                 */
                const createPKCS12 = (privateKey, certificates, password, friendlyName) => {
                    try {
                        // Create a new PKCS#12 object
                        const p12 = forge.pkcs12.toPkcs12Asn1(
                            privateKey,
                            certificates,
                            password,
                            {
                                algorithm: '3des', // Use 3DES for compatibility with Azure
                                count: 2048,
                                saltSize: 8,
                                useMac: true,
                                localKeyId: forge.random.getBytesSync(20),
                                friendlyName: friendlyName,
                                generateLocalKeyId: true
                            }
                        );
                        
                        return p12;
                        
                    } catch (error) {
                        throw new Error('Failed to create PKCS#12 bundle: ' + error.message);
                    }
                };
                
                /**
                 * Download PFX file
                 */
                const downloadPFX = () => {
                    try {
                        if (!state.pfxData) {
                            showMessage('pfxMessage', 'No PFX data available. Please generate PFX first.', 'warning');
                            return;
                        }
                        
                        // Decode base64
                        const pfxBytes = forge.util.decode64(state.pfxData);
                        const blob = new Blob([stringToArrayBuffer(pfxBytes)], { type: 'application/x-pkcs12' });
                        
                        // Create download link
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = state.pfxFileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        showMessage('pfxMessage', 'PFX file downloaded successfully!', 'success');
                        
                        // Auto-cleanup after 5 seconds
                        setTimeout(() => {
                            if (confirm('PFX file downloaded. Clear all sensitive data from memory?')) {
                                clearAll();
                            }
                        }, 5000);
                        
                    } catch (error) {
                        console.error('Error downloading PFX:', error);
                        showMessage('pfxMessage', 'Error downloading PFX: ' + error.message, 'error');
                    }
                };
                
                /**
                 * Utility: Convert string to ArrayBuffer
                 */
                const stringToArrayBuffer = (str) => {
                    const buffer = new ArrayBuffer(str.length);
                    const view = new Uint8Array(buffer);
                    for (let i = 0; i < str.length; i++) {
                        view[i] = str.charCodeAt(i);
                    }
                    return buffer;
                };
                
                /**
                 * Update progress bar
                 */
                const updateProgress = (percent, text) => {
                    DOM.progressFill.style.width = percent + '%';
                    DOM.progressFill.textContent = text || `${Math.round(percent)}%`;
                };
                
                /**
                 * Read file as certificate (handles both PEM and DER formats)
                 */
                const readFileAsCertificate = async (file) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const content = e.target.result;
                                
                                // Check if it's already PEM format (text)
                                if (typeof content === 'string' && content.includes('BEGIN CERTIFICATE')) {
                                    resolve(content);
                                    return;
                                }
                                
                                // Try to detect if it's binary/DER format
                                const uint8Array = new Uint8Array(e.target.result);
                                
                                // Check if it looks like text (all printable ASCII)
                                let isText = true;
                                for (let i = 0; i < Math.min(100, uint8Array.length); i++) {
                                    const byte = uint8Array[i];
                                    if (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) {
                                        isText = false;
                                        break;
                                    }
                                }
                                
                                if (isText) {
                                    // It's text, decode as UTF-8
                                    const text = new TextDecoder().decode(uint8Array);
                                    resolve(text);
                                } else {
                                    // It's binary (DER format), convert to PEM
                                    console.info('Detected DER format certificate, converting to PEM...');
                                    try {
                                        const asn1 = forge.asn1.fromDer(forge.util.createBuffer(uint8Array));
                                        const cert = forge.pki.certificateFromAsn1(asn1);
                    DOM.addMoreCertBtn.style.display = 'none';
                                        const pem = forge.pki.certificateToPem(cert);
                                        console.info('Successfully converted DER to PEM format');
                                        resolve(pem);
                                    } catch (derError) {
                                        console.error('Failed to parse as DER:', derError);
                                        reject(new Error('File is not a valid PEM or DER certificate'));
                                    }
                                }
                            } catch (error) {
                                reject(new Error('Failed to process certificate file: ' + error.message));
                            }
                        };
                        reader.onerror = (e) => reject(new Error('Failed to read file'));
                        
                        // Read as ArrayBuffer to handle both text and binary
                        reader.readAsArrayBuffer(file);
                    });
                };
                
                /**
                 * Read file as text
                 */
                const readFileAsText = (file) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = (e) => reject(new Error('Failed to read file'));
                        reader.readAsText(file);
                    });
                };
                
                /**
                 * Clear certificate data
                 */
                const clearCertificates = () => {
                    state.certificates = [];
                    DOM.certText.value = '';
                    DOM.certFile.value = '';
                    DOM.certFileName.textContent = 'No file selected';
                    DOM.certInfoDisplay.innerHTML = '';
                    DOM.addMoreCertBtn.style.display = 'none';
                    clearMessage('certMessage');
                };
                
                /**
                 * Clear private key data
                 */
                const clearPrivateKey = () => {
                    state.privateKey = null;
                    DOM.keyText.value = '';
                    DOM.keyFile.value = '';
                    DOM.keyFileName.textContent = 'No file selected';
                    DOM.keyPassword.value = '';
                    clearMessage('keyMessage');
                };
                
                /**
                 * Clear PFX data
                 */
                const clearPFXData = () => {
                    state.pfxData = null;
                    DOM.pfxPassword.value = '';
                    DOM.pfxPasswordConfirm.value = '';
                    DOM.friendlyName.value = '';
                    DOM.downloadPfxBtn.style.display = 'none';
                    clearMessage('pfxMessage');
                };
                
                /**
                 * Handle PFX file selection for checking
                 */
                const handleCheckPfxFileChange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        DOM.checkPfxFileName.textContent = file.name;
                    } else {
                        DOM.checkPfxFileName.textContent = 'No file selected';
                    }
                };
                
                /**
                 * Check PFX bundle - unpack and validate
                 */
                const checkPfxBundle = async () => {
                    try {
                        showLoading(DOM.checkPfxBtn);
                        clearMessage('checkMessage');
                        DOM.pfxContentsDisplay.innerHTML = '';
                        DOM.pfxChainStatus.style.display = 'none';
                        clearMessage('pfxChainMessage');
                        
                        // Get file and password
                        if (!DOM.checkPfxFile.files.length) {
                            showMessage('checkMessage', 'Please select a PFX file.', 'warning');
                            return;
                        }
                        
                        const password = DOM.checkPfxPassword.value;
                        if (!password) {
                            showMessage('checkMessage', 'Please enter the PFX password.', 'warning');
                            return;
                        }
                        
                        showMessage('checkMessage', 'Reading PFX file...', 'info');
                        
                        // Read file as ArrayBuffer
                        const file = DOM.checkPfxFile.files[0];
                        const arrayBuffer = await file.arrayBuffer();
                        const pfxBytes = new Uint8Array(arrayBuffer);
                        
                        showMessage('checkMessage', 'Decrypting PFX bundle...', 'info');
                        
                        // Convert to forge buffer
                        const pfxBuffer = forge.util.createBuffer(pfxBytes);
                        const pfxAsn1 = forge.asn1.fromDer(pfxBuffer);
                        
                        // Parse PKCS#12
                        let p12;
                        try {
                            p12 = forge.pkcs12.pkcs12FromAsn1(pfxAsn1, password);
                        } catch (error) {
                            throw new Error('Failed to decrypt PFX. Please check the password.');
                        }
                        
                        showMessage('checkMessage', 'Extracting certificates...', 'info');
                        
                        // Extract certificates and key
                        const extractedCerts = [];
                        let extractedKey = null;
                        
                        // Get all bags
                        const bags = p12.getBags({ bagType: forge.pki.oids.certBag });
                        const keyBags = p12.getBags({ bagType: forge.pki.oids.pkcs8ShroudedKeyBag });
                        
                        // Extract certificates
                        if (bags[forge.pki.oids.certBag]) {
                            for (const bag of bags[forge.pki.oids.certBag]) {
                                const cert = bag.cert;
                                const pem = forge.pki.certificateToPem(cert);
                                
                                extractedCerts.push({
                                    pem: pem,
                                    cert: cert,
                                    subject: cert.subject.attributes.map(attr => `${attr.shortName}=${attr.value}`).join(', '),
                                    issuer: cert.issuer.attributes.map(attr => `${attr.shortName}=${attr.value}`).join(', '),
                                    serialNumber: cert.serialNumber,
                                    notBefore: cert.validity.notBefore,
                                    notAfter: cert.validity.notAfter,
                                    fingerprint: forge.md.sha256.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex(),
                                    friendlyName: bag.friendlyName || null
                                });
                            }
                        }
                        
                        // Extract private key
                        if (keyBags[forge.pki.oids.pkcs8ShroudedKeyBag] && keyBags[forge.pki.oids.pkcs8ShroudedKeyBag].length > 0) {
                            extractedKey = keyBags[forge.pki.oids.pkcs8ShroudedKeyBag][0].key;
                        }
                        
                        if (extractedCerts.length === 0) {
                            showMessage('checkMessage', 'No certificates found in PFX bundle.', 'error');
                            return;
                        }
                        
                        // Sort certificates
                        const sortedCerts = sortCertificates(extractedCerts);
                        
                        // Display certificate information
                        displayPfxCertificateInfo(sortedCerts, extractedKey);
                        
                        // Validate chain
                        const chainAnalysis = analyzeChain(sortedCerts);
                        displayPfxChainStatus(chainAnalysis);
                        
                        showMessage('checkMessage', `Successfully loaded PFX bundle with ${sortedCerts.length} certificate(s).`, 'success');
                        
                    } catch (error) {
                        console.error('Error checking PFX bundle:', error);
                        showMessage('checkMessage', 'Error checking PFX: ' + error.message, 'error');
                    } finally {
                        hideLoading(DOM.checkPfxBtn);
                    }
                };
                
                /**
                 * Display PFX certificate information
                 */
                const displayPfxCertificateInfo = (certificates, privateKey) => {
                    let html = '<div class=\"cert-info\"><div class=\"cert-info-title\">PFX Bundle Contents:</div>';
                    
                    certificates.forEach((certInfo, index) => {
                        const isSelfSigned = certInfo.subject === certInfo.issuer;
                        const certType = isSelfSigned ? 'Root CA' : (index === 0 ? 'Leaf Certificate' : 'Intermediate CA');
                        
                        // Extract AIA information
                        const aiaInfo = extractAIAUrls(certInfo.cert);
                        
                        html += `
                            <div style=\"margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc;\">
                                <strong>Certificate ${index + 1} (${certType}):</strong><br>`;
                        
                        if (certInfo.friendlyName) {
                            html += `Friendly Name: ${certInfo.friendlyName}<br>`;
                        }
                        
                        html += `Subject: ${certInfo.subject}<br>
                                Issuer: ${certInfo.issuer}<br>`;
                        
                        // For root certificates or certificates without AIA, show formatted serial and thumbprint
                        if (isSelfSigned || (aiaInfo.caIssuers.length === 0 && aiaInfo.ocsp.length === 0)) {
                            html += `Serial: ${formatHexWithColons(certInfo.serialNumber)}<br>`;
                        } else {
                            html += `Serial: ${certInfo.serialNumber}<br>`;
                        }
                        
                        html += `Valid: ${certInfo.notBefore.toLocaleDateString()} - ${certInfo.notAfter.toLocaleDateString()}<br>`;
                        
                        // For root certificates or certificates without AIA, show formatted thumbprint
                        if (isSelfSigned || (aiaInfo.caIssuers.length === 0 && aiaInfo.ocsp.length === 0)) {
                            html += `SHA-256 Thumbprint: ${formatHexWithColons(certInfo.fingerprint)}`;
                        } else {
                            html += `SHA-256: ${certInfo.fingerprint}`;
                        }
                        
                        // Add AIA information if available
                        if (aiaInfo.caIssuers.length > 0 || aiaInfo.ocsp.length > 0) {
                            html += '<br><strong>AIA Extensions:</strong><br>';
                            if (aiaInfo.caIssuers.length > 0) {
                                html += '&nbsp;&nbsp;CA Issuers URLs:<br>';
                                aiaInfo.caIssuers.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href=\"${url}\" target=\"_blank\" style=\"color: #2196F3;\">${url}</a><br>`;
                                });
                            }
                            if (aiaInfo.ocsp.length > 0) {
                                html += '&nbsp;&nbsp;OCSP URLs:<br>';
                                aiaInfo.ocsp.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href=\"${url}\" target=\"_blank\" style=\"color: #2196F3;\">${url}</a><br>`;
                                });
                            }
                        } else if (isSelfSigned) {
                            // Show root certificate download links
                            const rootLinks = getRootCertDownloadLinks(certInfo.subject, certInfo.issuer);
                            if (rootLinks.length > 0) {
                                html += '<br><strong>Download Root Certificate:</strong><br>';
                                rootLinks.forEach(link => {
                                    html += `&nbsp;&nbsp;• <a href=\"${link.url}\" target=\"_blank\" style=\"color: #4CAF50;\">${link.name}</a><br>`;
                                });
                            }
                        }
                        
                        html += `
                            </div>
                        `;
                    });
                    
                    // Add private key info
                    html += '<div style=\"margin-top: 8px; padding-top: 8px; border-top: 1px solid #ccc;\">';
                    html += '<strong>Private Key:</strong><br>';
                    if (privateKey) {
                        html += '✓ Private key found in bundle<br>';
                        
                        // Verify key matches first certificate
                        if (certificates.length > 0) {
                            const cert = certificates[0].cert;
                            const publicKey = cert.publicKey;
                            
                            if (privateKey.n && publicKey.n) {
                                if (privateKey.n.toString() === publicKey.n.toString()) {
                                    html += '✓ Private key matches the leaf certificate';
                                } else {
                                    html += '✗ Private key does NOT match the leaf certificate';
                                }
                            }
                        }
                    } else {
                        html += '✗ No private key found in bundle';
                    }
                    html += '</div>';
                    
                    html += '</div>';
                    DOM.pfxContentsDisplay.innerHTML = html;
                };
                
                /**
                 * Display PFX chain status
                 */
                const displayPfxChainStatus = (analysis) => {
                    const statusClass = analysis.complete ? 'chain-complete' : 'chain-incomplete';
                    DOM.pfxChainStatus.className = `chain-status ${statusClass}`;
                    DOM.pfxChainStatus.style.display = 'block';
                    
                    let html = `<strong>Chain Analysis:</strong><br>`;
                    html += `Total Certificates: ${analysis.chainDetails.length}<br>`;
                    html += `Missing Intermediates: ${analysis.missingCount}<br><br>`;
                    
                    analysis.chainDetails.forEach((detail) => {
                        const status = detail.isSelfSigned ? '✓ Root CA' : (detail.hasIssuerInChain ? '✓ Valid' : '✗ Issuer missing');
                        html += `[${detail.index + 1}] ${status}: ${detail.subject}<br>`;
                        
                        // Add AIA information for missing issuers
                        if (!detail.isSelfSigned && !detail.hasIssuerInChain && detail.aiaInfo) {
                            if (detail.aiaInfo.caIssuers.length > 0) {
                                html += `&nbsp;&nbsp;&nbsp;&nbsp;<strong>Missing certificate can be downloaded from:</strong><br>`;
                                detail.aiaInfo.caIssuers.forEach(url => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• <a href=\"${url}\" target=\"_blank\" style=\"color: #2196F3;\">${url}</a><br>`;
                                });
                            } else {
                                html += `&nbsp;&nbsp;&nbsp;&nbsp;⚠ No CA Issuer URLs in AIA extension<br>`;
                                
                                // Show root certificate download links
                                const rootLinks = getRootCertDownloadLinks(detail.subject, detail.issuer);
                                if (rootLinks.length > 0) {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;<strong>Download from CA:</strong><br>`;
                                    rootLinks.forEach(link => {
                                        html += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;• <a href=\"${link.url}\" target=\"_blank\" style=\"color: #4CAF50;\">${link.name}</a><br>`;
                                    });
                                }
                            }
                        }
                    });
                    
                    if (analysis.missingIssuers.length > 0) {
                        html += `<br><strong>Missing Issuers:</strong><br>`;
                        analysis.missingIssuers.forEach((issuer) => {
                            html += `• ${issuer}<br>`;
                            
                            const rootLinks = getRootCertDownloadLinks(issuer, issuer);
                            if (rootLinks.length > 0) {
                                html += `&nbsp;&nbsp;<strong>Download from CA:</strong><br>`;
                                rootLinks.forEach(link => {
                                    html += `&nbsp;&nbsp;&nbsp;&nbsp;• <a href=\"${link.url}\" target=\"_blank\" style=\"color: #4CAF50;\">${link.name}</a><br>`;
                                });
                            }
                        });
                    }
                    
                    DOM.pfxChainStatusText.innerHTML = html;
                    
                    // Display message
                    if (analysis.complete) {
                        showMessage('pfxChainMessage', 'Certificate chain is complete and valid! ✓', 'success');
                    } else {
                        showMessage('pfxChainMessage', `Chain incomplete. Missing ${analysis.missingCount} intermediate certificate(s).`, 'warning');
                    }
                };
                
                /**
                 * Clear PFX checker
                 */
                const clearPfxChecker = () => {
                    DOM.checkPfxFile.value = '';
                    DOM.checkPfxFileName.textContent = 'No file selected';
                    DOM.checkPfxPassword.value = '';
                    DOM.pfxContentsDisplay.innerHTML = '';
                    DOM.pfxChainStatus.style.display = 'none';
                    clearMessage('checkMessage');
                    clearMessage('pfxChainMessage');
                };
                
                /**
                 * Clear all data
                 */
                const clearAll = () => {
                    clearCertificates();
                    clearPrivateKey();
                    clearPFXData();
                    DOM.chainStatus.style.display = 'none';
                    DOM.chainInfoDisplay.innerHTML = '';
                    clearMessage('chainMessage');
                    state.chainComplete = false;
                    showMessage('certMessage', 'All data cleared from memory.', 'info');
                };
                
                /**
                 * Perform security check
                 */
                const performSecurityCheck = () => {
                    let html = '<strong>Security Status:</strong><br>';
                    
                    // Check HTTPS
                    if (window.location.protocol === 'https:' || window.location.hostname === 'localhost') {
                        html += '✓ Secure connection (HTTPS)<br>';
                    } else {
                        html += '✗ Insecure connection (HTTP) - Use HTTPS!<br>';
                    }
                    
                    // Check if data is loaded
                    html += `✓ Certificates loaded: ${state.certificates.length}<br>`;
                    html += `✓ Private key loaded: ${state.privateKey ? 'Yes' : 'No'}<br>`;
                    html += `✓ Chain complete: ${state.chainComplete ? 'Yes' : 'No'}<br>`;
                    html += `✓ PFX generated: ${state.pfxData ? 'Yes' : 'No'}<br>`;
                    
                    // Memory info
                    html += '<br><strong>Memory Management:</strong><br>';
                    html += '✓ All data stored in memory only<br>';
                    html += '✓ No server-side uploads<br>';
                    html += '✓ Automatic cleanup on page unload<br>';
                    
                    DOM.securityDetails.innerHTML = html;
                    DOM.securityReport.style.display = 'block';
                };
                
                /**
                 * Show message
                 */
                const showMessage = (elementId, message, type) => {
                    const element = document.getElementById(elementId);
                    element.innerHTML = `<div class="${type}">${message}</div>`;
                };
                
                /**
                 * Clear message
                 */
                const clearMessage = (elementId) => {
                    const element = document.getElementById(elementId);
                    element.innerHTML = '';
                };
                
                /**
                 * Show loading state
                 */
                const showLoading = (button) => {
                    button.classList.add('loading');
                    button.disabled = true;
                };
                
                /**
                 * Hide loading state
                 */
                const hideLoading = (button) => {
                    button.classList.remove('loading');
                    button.disabled = false;
                };
                
                /**
                 * Cleanup on page unload
                 */
                const cleanup = () => {
                    try {
                        // Clear sensitive data from memory
                        state.certificates = [];
                        state.privateKey = null;
                        state.pfxData = null;
                        
                        console.info('Sensitive data cleared from memory');
                    } catch (error) {
                        console.error('Cleanup error:', error);
                    }
                };
                
                // Initialize
                init();
                
                // Return public API for debugging
                return {
                    state: state,
                    clearAll: clearAll
                };
            })();
            
            // Global error handlers
            window.addEventListener('error', (e) => {
                console.error('Global error:', e.error);
            });
            
            window.addEventListener('unhandledrejection', (e) => {
                console.error('Unhandled promise rejection:', e.reason);
            });
        }
        
        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
